# IP
## Internet Protocol

인터넷 프로토콜은 **송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고 받는 데 사용하는 규악**이다.
쉽게 말하면 인터넷 망 속에서 클라이언트와 서버가 통신할 수 있는 약속이라 할 수 있다.

> 패킷 교환 네트워크란? 작은 블록의 패킷으로 데이터를 전송하는 네트워크를 말한다.

## IP 주소
  - IP 주소 종류
    - `IPv4`: 32bit를 사용하는 IP 주소 체계로, 보통 해석을 쉽게 하기 위해 1B씩 끊어서 십진법으로 표현한다.
        >   ex. 255.255.1.0
    - `IPv6`: 128bit를 사용하며 16bit 단위로 구분한다. Ipv4의 주소 고갈 문제를 해결한다.
  - 특별한 IP 주소
    - loopback 주소: 한 컴퓨터에서 서버와 클라이언트를 테스트하고 싶을 때 사용한다.(내가 보낸 패킷을 내가 수신하는 것)
      - IPv4: 127.X.X.X(대부분 127.0.0.1 사용)
      - IPv6: ::1(0:0:0:0:0:0:1의 약자)
  - IP 주소 vs MAC 주소

![Image](https://github.com/user-attachments/assets/f04b8bf8-40ec-4787-89d9-f0146b01750f)
***
# PORT
네트워크 서비스나 **특정 프로세스를 식별**하는 논리단위이다. 각 포트는 번호로 구별되며 이 번호를 포트 번호라고 한다.

주로 PORT를 사용하는 프로토콜은 전송 계층 프로토콜이라 하며, 대표적으로 `TCP`와 `UDP`가 있다.
- well-known port : 0번 ~ 1023번 포트
  - 80: HTTP
  - 443: HTTPS
***
# CIDR
클래스 기반 IP 주소란 A클래스, B클래스 등 각 클래스마다 할당되는 호스트 갯수가 정해진 IP주소이다.

이때, 클래스 기반 IP주소에서는 300개의 호스트를 가지고 싶은 기업은 254개의 호스트를 지원하는 C클래스 IP주소를 사용할 수 없고 6만 5,534개의 호스트를 제공하는 B클래스 IP 주소를 사용해야 한다.

또한 192.168.1.0과 192.168.0.0은 다른 C클래스 네트워크로 두 네트워크를 하나로 결합할 수는 없었다.

이러한 문제를 해결하는 IP 주소 할당 방법이 `CIDR`이다.

CIDR은 Classless Inter-Domain Routing의 약자로 인터넷 상의 데이터 라우팅 효율성을 향상시키는 IP 주소 할당 방법이다.

크게 와닿지 않으니, CIDR 표기법을 이해하고 클래스 기반 IP 주소와 비교하여 이점을 살펴보겠다.

- CIDR 표기법
  ![Image](https://github.com/user-attachments/assets/d5d1d338-3bfd-4bca-a1a7-bf7290bb6d10)
  ![Image](https://github.com/user-attachments/assets/f4efedb6-e58c-4bb6-8bf5-bf13e3532f18)

  `a.b.c.d/x` (x: 네트워크 부분의 비트 수 -> x에 따라서 할당되는 호스트의 수를 조정할 수 있다.)
  > ex. 10.10.0.0/24는 네트워크 부분 24bit(10.10.0)과 호스트 부분 8bit(.0)으로 구분할 수 있고, 
  > 10.10.0.0~10.10.0.255까지 사용 가능하다.
- `CIDR 블록`: 동일한 네트워크 접두사와 비트 수를 공유하는 IP 주소 모음
  > ex. 10.10.0.0/16인 CIDR 블록에는 10.10.1.0/24, 10.10.2.0/24 등 서브넷이 존재한다. 
  > 이때 동일한 네트워크 접두사(10.10.)와 동일한 네트워크 비트 수(16bit)를 공유한다.
- 클래스 기반 IP 주소에서 CIDR을 사용했을 때 이점
  - 앞선 300개의 호스트는 네트워크를 23bit로 두면서 512개의 호스트를 사용하여 IP 주소 낭비를 줄일 수 있다. CIDR을 사용하면 특정 네트워크에 필요한 수에 맞추어 IP 주소를 사용할 수 있다.
  - 라우터는 패킷의 목적지 IP 주소와 CIDR 블록의 네트워크 접두사를 비교하여 가장 적합한 경로를 빠르게 결정할 수 있다. 따라서 라우팅 프로세스를 단순화하고 가속하는 데 일조한다.
    > classless 라우팅 테이블
    > 
    > IP 헤더에서 목적지 주소 추출 -> subnet mask로 subnet 주소 추출 -> 해당 subnet 주소 라우팅 테이블에서 찾기 -> ...
    > 
    > classful 라우팅 테이블
    >
    > IP 헤더에서 목적지 주소 추출 -> 목적지 주소에서 클래스 찾기 -> 네트워크 대표 주소 추출하기 -> 해당 클래스 라우팅 테이블에서 찾기 -> ...
***
# TCP와 UDP 차이
## TCP
Transmission Control Protocol은 IP 규칙으로만 통신하기에 부족하거나 불안정하던 여러 단점들(패킷 순서, 패킷 유실, ...)을 보완하기 위해 패킷 전송을 제어하여 신뢰성을 보증하는 프로토콜이다.
![Image](https://github.com/user-attachments/assets/7126ae2a-cc34-4ecb-b9c8-c17d0b441d52)

> 🤔 통신을 시작할 때는 3-way? 통신을 마칠 때는 4-way?
> 
> 서버 설계에 따라 FIN+ACK을 동시에 보낼 경우 3-way handshake로도 종료될 수 있다.
1. 흐름 제어(Flow Control): 생산자가 데이터를 생산하는 속도와 소비자가 데이터를 소비하는 속도의 밸런스를 조절한다.
   - Sliding Window 방식
2. 오류 제어(Error Control)
  - Go Bank N 기법: 오류난 데이터부터 순서대로 보내는 방법
  - Selective Repeat 기법: 오류난 데이터만 재전송하고, 순서가 잘못된 데이터를 재정렬하는 방법
3. 혼잡 제어(Congestion Control): 네트워크 혼잡 상태가 감지되면 송신 측에서 전송 데이터 크기를 조절하여 전송량을 제어한다.
## TCP와 UDP 차이
![Image](https://github.com/user-attachments/assets/ed71bef6-9629-4a7a-874c-4e4fff3b51f8)

- 연결 방식: TCP는 연결형 서비스로 3-way handshake, 4-way handshake 연결 설정, 종료 과정이 존재하지만, 

  UDP는 비연결형 서비스로 연결 설정과 종료 과정이 없다.
- 패킷 교환: 패킷의 교환 방식은 가상회선 방식과 데이터그램 방식으로 구분된다. 
  
  가상회선 방식은 패킷의 논리적 연결을 설정하고 패킷이 어떤 경로를 지나갈지 경로를 한 번만 설정하며 분할된 패킷은 동일한 경로를 통해 전달된다. 

  데이터그램방식은 논리적 연결 설정 없이 패킷이 독립적으로 전달된다. 하나의 메시지에서 분할된 패킷들은 여러 라우터를 거칠 때마다 경로 설정을 수행하여 전달된다.
- 전송 순서 보장: TCP는 송신측에서 데이터를 세그먼트로 나누어서 순서대로 전송하고 수신측에서 segment를 통해 전송 순서를 확인한다. 

  반면 UDP는 개별 메시지 단위로 처리되며, 송신측에서 독립적으로 전송하면 수신측에서 순서나 데이터 무결성을 자체적으로 관리한다.
- 신뢰성: 앞선 연결 방식과 전송 순서 보장 유무에 따라 TCP는 신뢰성이 중요한 애플리케이션에서, 

  UDP는 데이터 도착을 보장하거나 순서대로 데이터를 재정렬하지 않으므로 지연 시간이 중요한 애플리케이션에서 사용된다.
***
# Web Server와 WAS의 차이
## Web Server
HTTP 프로토콜로 서로 데이터를 주고 받을 수 있는 사용자에게 일괄적인 **정적 데이터**(정적 HTML, CSS, JS, 이미지, 영상 등)를 제공한다.

대표적으로 Nginx, Apache가 있다.
## WAS
Web Application Server로 HTTP 기반으로 동작하며 웹 서버의 기능을 포함하여 **애플리케이션 로직을 수행**하여 동적 HTML, HTTP API등을 제공한다.

대표적으로 Tomcat, Jetty가 있다.

WAS는 Web Server와 Web Container로 이루어졌다.
`Web Container`는 JSP와 Servlet을 실행시킬 수 있는 환경을 제공하는 소프트웨어로 Servlet 컨테이너, JSP 컨테이너 등이 있다.
> 🤔 
> 
> `Servlet`: 자바 기반 웹 서버나 애플리케이션 서버를 실행하는 자바 프로그램으로 
> 클라이언트 요청을 다루고 처리하며 동적으로 응답을 생성한다.
> 
> Java Servlet 실행 단계
> 1. 클라이언트가 Web Server에 요청을 보낸다.
> 2. Web Server가 요청을 받는다.
> 3. Web Server가 대응되는 서블릿에 요청을 위임한다.
> 4. 서블릿은 요청을 처리하고(doGet(), doPost()) 응답을 알맞는 형태로 생성한다.
> 5. 서블릿은 응답을 Web Server로 다시 보낸다.
> 6. Web Server는 클라이언트에게 응답을 보내고 클라이언트 브라우저는 화면에 이를 띄운다.

## Web Server와 WAS 차이
WAS는 애플리케이션 코드를 실행하는 데 더 특화된 서버이다.
## 웹 시스템 구성
1. WAS + DB
- 가장 최소한의 웹 시스템.
- WAS가 너무 많은 역할을 담당하여 서버의 과부하가 우려된다.
- WAS 장애 시, 오류 화면을 제공할 수 없다.
2. Web Server + WAS + DB
- 정적 리소스는 웹 서버가 처리하고 동적인 처리가 필요하면 WAS에 요청을 위임하는 구조이다.
- 정적 리소스, 애플리케이션 리소스 중 많이 사용되는 것에 따라 웹 서버나 WAS를 증설함으로써 **효율적으로 리소스 관리**가 가능하다.
- WAS는 웹 서버에 비해 애플리케이션 로직이 동작하여 장애가 나기 쉽다. 

  이에 대비하여 WAS나 DB 장애 시 웹 서버가 오류 화면을 제공할 수 있는 구조다.
***
### 실습
![Image](https://github.com/user-attachments/assets/1083537e-65f3-4052-ba9c-b19bc63e4e78)